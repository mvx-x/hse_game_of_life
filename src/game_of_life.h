/**
 * @file game_of_life.h
 * @brief Заголовочный файл для реализации игры "Жизнь" Конвея
 *
 * Программа моделирует клеточный автомат по правилам:
 * 1. Мертвая клетка оживает, если рядом ровно 3 живых соседа
 * 2. Живая клетка выживает, если рядом 2 или 3 живых соседа
 * 3. Во всех остальных случаях клетка умирает (от одиночества или
 * перенаселения)
 */

#pragma once
#include <SFML/Graphics.hpp>
#include <vector>

 /**
  * @class GameOfLife
  * @brief Реализует логику клеточного автомата Конвея
  *
  * Класс инкапсулирует:
  * - Текущее состояние клеточного поля (двумерный вектор)
  * - Методы для эволюции системы по правилам "Игры Жизнь"
  *
  * Использует двойную буферизацию для предотвращения артефактов обновления:
  * - grid - текущее состояние клеток
  * - nextGrid - расчитываемое состояние следующего поколения
  */
class GameOfLife {
public:
    /**
     * @brief Инициализирует игровое поле
     * @param width Ширина сетки в клетках (требуется > 0)
     * @param height Высота сетки в клетках (требуется > 0)
     * @note Создает два идентичных буфера (grid и nextGrid)
     *       Все клетки инициализируются в "мертвом" состоянии
     */
    GameOfLife(int width, int height);

    /**
     * @brief Заполняет сетку случайными состояниями
     *
     * Генерирует равномерное распределение:
     * - Вероятность жизни клетки ~50%
     * - Использует аппаратный источник энтропии (std::random_device)
     * - Гарантирует различную инициализацию при каждом запуске
     */
    void randomize();

    /**
     * @brief Сбрасывает все клетки в "мертвое" состояние
     *
     * Эффективно очищает игровое поле:
     * - grid - основной буфер
     * - nextGrid - вспомогательный буфер (очищается при следующем update)
     */
    void clear();

    /**
     * @brief Инвертирует состояние указанной клетки
     * @param x Координата X клетки (отсчет от 0)
     * @param y Координата Y клетки (отсчет от 0)
     *
     * Безопасный метод:
     * - Автоматически проверяет границы поля
     * - Работает в режимах паузы/симуляции
     * - Немедленно отражается на визуализации
     */
    void toggleCell(int x, int y);

    /**
     * @brief Вычисляет следующее поколение клеток
     *
     * Алгоритм:
     * 1. Для каждой клетки подсчитывает живых соседей
     * 2. Применяет правила Конвея для определения нового состояния
     * 3. Сохраняет новое состояние во вспомогательный буфер (nextGrid)
     * 4. Обменивает буферы местами (swap)
     * 5. Сбрасывает nextGrid для следующих вычислений
     *
     * @note Сложность O(N*M), где N и M - размеры сетки
     */
    void update();

    /**
     * @brief Проверяет, жива ли клетка в указанной позиции
     * @param x Координата X клетки
     * @param y Координата Y клетки
     * @return true если клетка жива, false в противном случае
     */
    bool isCellAlive(int x, int y) const;

    /**
     * @brief Возвращает размеры сетки
     * @return Пара {ширина, высота} в клетках
     */
    std::pair<int, int> getGridSize() const;

    /**
     * @brief Устанавливает цвет для живых клеток
     * @param color Новый цвет клеток
     *
     * @note Изменение цвета применяется немедленно
     * @note Цвет применяется только к живым клеткам
     */
    void setCellColor(const sf::Color& color);

    /**
     * @brief Отрисовывает текущее состояние на SFML-канвасе
     * @param window Целевое окно рендеринга
     * @param cellSize Размер клетки в пикселях (влияет на масштаб)
     *
     * Визуализация:
     * - Живые клетки: квадраты текущего цвета (устанавливается setCellColor)
     * - Мертвые клетки: не отображаются (фон окна)
     * - Сетка: формируется зазорами между клетками (1px)
     */
    void draw(sf::RenderWindow& window, int cellSize) const;

    /**
     * @brief Возвращает текущий номер поколения
     * @return Количество выполненных обновлений с момента создания
     */
    int getGenerationCount() const;

    /**
     * @brief Сбрасывает счетчик поколений в 0
     */
    void resetGenerationCount();

    /**
     * @brief Подсчитывает количество живых клеток
     * @return Количество живых клеток на поле
     */
    int getLiveCellCount() const;

    /**
     * @brief Подсчитывает количество мертвых клеток
     * @return Количество мертвых клеток на поле
     */
    int getDeadCellCount() const;

    /**
     * @brief Вычисляет процент живых клеток
     * @return Процент живых клеток от общего количества (0.0 - 100.0)
     */
    double getLiveCellPercentage() const;

    /**
     * @brief Делает клетку бессмертной или снимает бессмертие (только для живых
     * клеток)
     * @param x Координата X клетки
     * @param y Координата Y клетки
     *
     * Если клетка жива и не бессмертна — становится бессмертной.
     * Если клетка жива и бессмертна — теряет бессмертие.
     * На мертвые клетки не влияет.
     */
    void toggleImmortal(int x, int y);

    /**
     * @brief Проверяет, является ли клетка бессмертной
     * @param x Координата X клетки
     * @param y Координата Y клетки
     * @return true если клетка бессмертна, false иначе
     */
    bool isImmortal(int x, int y) const;

private:
    int width;   ///< Ширина сетки (в клетках)
    int height;  ///< Высота сетки (в клетках)
    std::vector<std::vector<bool>>
        grid;  ///< Текущее состояние клеток (true = живая)
    std::vector<std::vector<bool>>
        nextGrid;  ///< Буфер для расчета следующего состояния
    std::vector<std::vector<bool>>
        immortal;  ///< Флаг бессмертия для каждой клетки (true = бессмертна)
    sf::Color cellColor = sf::Color::Green;  ///< Цвет живых клеток для отрисовки
    int generationCount = 0;  ///< Счетчик поколений

    /**
     * @brief Подсчитывает живых соседей для клетки
     * @param x Координата X ц��левой клетки
     * @param y Координата Y целевой клетки
     * @return Число живых соседей [0, 8]
     *
     * Особенности:
     * - Игнорирует центральную клетку (dx=0, dy=0)
     * - Корректно обрабатывает граничные клетки (не учитывает вне сетки)
     * - Тороидальная топология НЕ реализована (классические правила)
     */
    int countLiveNeighbors(int x, int y) const;
};